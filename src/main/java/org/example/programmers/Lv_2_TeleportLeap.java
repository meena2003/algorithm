package org.example.programmers;

/**
 * 혼자 힘으로 풀었다.
 * 역시 원리만 깨우치면 생각보다 어렵지 않았다.
 * 텔레포트는 공짜다. 그래서 가장 최우선으로 선택해야 한다.
 * 텔레포트는 결국 2배씩 거리를 이동하는 것이기 때문에, 반대로 n / 2가 되는 순간 전부 공짜로 이동이 가능하다.
 * 하지만 2로 나눠지지 않는다면, 최단 거리(즉 텔레포트 조건 거리)로 이동하기 위해 한 칸 +1 하면 된다.
 * 따라서 n을 2로 나누면서 나눠 떨어지지 않는 구간에서 한 칸 +1 하면 된다.
 */
public class Lv_2_TeleportLeap {
    public static void main(String[] args) {
        solution(5);
    }

    /*
    정확성  테스트
        테스트 1 〉	통과 (0.02ms, 76MB)
        테스트 2 〉	통과 (0.02ms, 83.1MB)
        테스트 3 〉	통과 (0.02ms, 73.7MB)
        테스트 4 〉	통과 (0.03ms, 71.5MB)
        테스트 5 〉	통과 (0.01ms, 91.2MB)
        테스트 6 〉	통과 (0.03ms, 73.3MB)
        테스트 7 〉	통과 (0.02ms, 73.8MB)
        테스트 8 〉	통과 (0.03ms, 81.1MB)
        테스트 9 〉	통과 (0.02ms, 73.2MB)
        테스트 10 〉	통과 (0.02ms, 78.1MB)
        테스트 11 〉	통과 (0.02ms, 71.9MB)
        테스트 12 〉	통과 (0.02ms, 66.1MB)
        테스트 13 〉	통과 (0.02ms, 80.5MB)
        테스트 14 〉	통과 (0.02ms, 82.2MB)
        테스트 15 〉	통과 (0.02ms, 76.9MB)
        테스트 16 〉	통과 (0.02ms, 77.6MB)
        테스트 17 〉	통과 (0.02ms, 70.1MB)
        테스트 18 〉	통과 (0.02ms, 73.9MB)
        효율성  테스트
        테스트 1 〉	통과 (0.02ms, 52.8MB)
        테스트 2 〉	통과 (0.02ms, 51.9MB)
        테스트 3 〉	통과 (0.02ms, 51.8MB)
        테스트 4 〉	통과 (0.02ms, 52.2MB)
        테스트 5 〉	통과 (0.02ms, 52.3MB)
        테스트 6 〉	통과 (0.02ms, 51.8MB)
        테스트 7 〉	통과 (0.02ms, 51.8MB)
        테스트 8 〉	통과 (0.02ms, 52.1MB)
        테스트 9 〉	통과 (0.02ms, 51.8MB)
        테스트 10 〉	통과 (0.02ms, 51.5MB)
     */
    public static int solution(int n) {
        int battery = 1;

        while (n != 1) {
            if (n % 2 != 0) {
                battery += 1;
            }
            n /= 2;
        }

        return battery;
    }
}
